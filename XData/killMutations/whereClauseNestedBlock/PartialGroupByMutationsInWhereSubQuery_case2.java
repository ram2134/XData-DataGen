package killMutations.whereClauseNestedBlock;

import generateConstraints.ConstraintGenerator;
import generateConstraints.GenerateCommonConstraintsForQuery;
import generateConstraints.GenerateConstraintsForConjunct;
import generateConstraints.GenerateConstraintsForHavingClause;
import generateConstraints.GenerateConstraintsForPartialGroup_case2;
import generateConstraints.GenerateConstraintsForWhereClauseSubQueryBlock;
import generateConstraints.GenerateGroupByConstraints;
import generateConstraints.UtilsRelatedToNode;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Vector;
import java.util.logging.Level;
import java.util.logging.Logger;

import parsing.ConjunctQueryStructure;
import parsing.Node;
import testDataGen.GenerateCVC1;
import testDataGen.QueryBlockDetails;
import util.TagDatasets;

/**
 * This class Generates data to kill partial group by mutations inside where clause sub query block
 * The data sets generated by this function are only capable of killing the mutations even if the group by attribute is not projected in select list of the output
 * Assumptions: Atleast two tuples are needed to satisfy the aggregation constraint. Otherwise it is not possible to generate the data sets
 * @author mahesh
 *
 */
public class PartialGroupByMutationsInWhereSubQuery_case2 {

	private static Logger logger = Logger.getLogger(PartialGroupByMutationsInWhereSubQuery_case2.class.getName());
	/**
	 * Generates data sets for killing partial group by attributes
	 * @param cvc
	 */
	public static void generateDataForkillingParialGroupByMutationsInWhereSubquery(	GenerateCVC1 cvc) throws Exception{
		
		/** keep a copy of this tuple assignment values */
		//HashMap<String, Integer> noOfOutputTuplesOrig = (HashMap<String, Integer>) cvc.getNoOfOutputTuples().clone();
		HashMap<String, Integer> noOfTuplesOrig = (HashMap<String, Integer>) cvc.getNoOfTuples().clone();
		HashMap<String, Integer[]> repeatedRelNextTuplePosOrig = (HashMap<String, Integer[]>)cvc.getRepeatedRelNextTuplePos().clone();

		/** we have to check if there are where clause sub queries in each conjunct of outer block of query */
		for(ConjunctQueryStructure con: cvc.getOuterBlock().getConjunctsQs()){
			
			/**For each where clause sub query blocks of this conjunct*/
			/** Kill partial group by  mutations in each where clause nested block of this query*/
			for(Node subQCond: con.getAllSubQueryConds()){
				
				/** get the index of this sub query node */
				int index = UtilsRelatedToNode.getQueryIndexOfSubQNode(subQCond);

				/** get the where clause sub query block */
				QueryBlockDetails qbt = cvc.getOuterBlock().getWhereClauseSubQueries().get(index);

				 logger.log(Level.INFO,"\n----------------------------------");
				logger.log(Level.INFO,"GENERATE DATA FOR KILLING MISSING GROUP BY MUTATIONS IN WHERE CLAUSE NESTED SUBQUERY BLOCK: Case 2: "+ qbt);
				logger.log(Level.INFO,"----------------------------------\n");
				
				/**Get group by nodes of this sub query block*/
				ArrayList<Node> groupbyNodes = (ArrayList<Node>)qbt.getGroupByNodes().clone();
				
				/**kill each group by attribute at a time*/
				for(Node tempgroupByNode : groupbyNodes){
					
				    logger.log(Level.INFO,"\n----------------------------------");
					logger.log(Level.INFO,"KILLING MISSING GROUP BY MUTATIONS IN WHERE CLAUSE NESTED SUBQUERY BLOCK: " + tempgroupByNode);
					logger.log(Level.INFO,"\n----------------------------------");
				
					
					/** Initialize the data structures for generating the data to kill this mutation */
					cvc.inititalizeForDatasetQs();

					/**set the type of mutation we are trying to kill*/
					cvc.setTypeOfMutation( TagDatasets.MutationType.PARTIALGROUPBY2, TagDatasets.QueryBlock.WHERE_SUBQUERY );
					
					/**FIXME: Does this group by attribute affect tuple assignment*/
					/** get the tuple assignment for this query
					 * If no possible assignment then not possible to kill this mutation*/
					if(GenerateCVC1.tupleAssignmentForQuery(cvc) == false)
						continue ;
					
					/** Add constraints for all the From clause nested sub query blocks */
					for(QueryBlockDetails qb: cvc.getOuterBlock().getFromClauseSubQueries()){						
						cvc.getConstraints().add(ConstraintGenerator.addCommentLine(" FROM CLAUSE SUBQUERY "));
						cvc.getConstraints().add( QueryBlockDetails.getConstraintsForQueryBlock(cvc, qb) );
						cvc.getConstraints().add(ConstraintGenerator.addCommentLine(" END OF FROM CLAUSE SUBQUERY "));						
					}
					
					/**add the negative constraints for all the other conjuncts of outer query block */
					for(ConjunctQueryStructure outer: cvc.getOuterBlock().getConjunctsQs())
						if( !outer.equals(con))
							cvc.getConstraints().add( GenerateConstraintsForConjunct.generateNegativeConstraintsConjunct(cvc, cvc.getOuterBlock(), outer) );
					
					/**FIXME: Make this aggregation constraint to fail in distinct tuples of killing group by attribute*/
					
					/** add group by and having clause constraints for outer query block */
					cvc.getConstraints().add( QueryBlockDetails.getGroupByAndHavingClauseConstraints(cvc, cvc.getOuterBlock())) ;

					/**Add other related constraints for the outer query block */
					cvc.getConstraints().add( QueryBlockDetails.getOtherConstraintsForQueryBlock(cvc, cvc.getOuterBlock())) ;


					/** Add all the constraints for this outer block conjunct except where clause sub query block constraints */
					cvc.getConstraints().add( GenerateConstraintsForConjunct.getConstraintsForConjuctExceptWhereClauseSubQueryBlock(cvc, qbt, con) );
					
					/** get where clause sub query block constraints for this conjunct. 
					 * Here we should add all the constraints of this conjunct except group by clause constraints of this where clause sub query
					 * But these group by constraints are added in getConstraintsforWhereClauseSubqueryBlock() method 
					 * so we add the constraints of this where clause sub query separately 
					 * get constraints for this sub query block except group by clause constraints
					 * Add the positive conditions for each conjunct of this query block */

					String constraintString = "";

					if(con.getAllSubQueryConds() != null){
						for(int i=0; i < con.getAllSubQueryConds().size(); i++){

							Node subQ = con.getAllSubQueryConds().get(i);
							constraintString +=ConstraintGenerator.addCommentLine("CONSTRAINTS FOR WHERE CLAUSE SUBQUERY CONNECTIVE ");
							constraintString += GenerateConstraintsForWhereClauseSubQueryBlock.getConstraintsForWhereSubQueryConnective(cvc, cvc.getOuterBlock(), subQ);

							constraintString += ConstraintGenerator.addCommentLine("CONSTRAINTS FOR CONDITIONS INSIDE WHERE CLAUSE SUBQUERY CONNECTIVE ");

							constraintString += GenerateConstraintsForWhereClauseSubQueryBlock.getCVCForCondsInSubQ(cvc, cvc.getOuterBlock(), subQ);				

							constraintString += ConstraintGenerator.addCommentLine("END OF CONSTRAINTS FOR CONDITIONS INSIDE WHERE CLAUSE SUBQUERY CONNECTIVE ");
						}
					}

					cvc.getConstraints().add(constraintString);
					
					/** Generate havingClause constraints for this sub query block*/
					cvc.getConstraints().add(ConstraintGenerator.addCommentLine("HAVING CLAUSE CONSTRAINTS FOR SUBQUERY BLOCK "));
					for(int j=0; j< qbt.getNoOfGroups();j ++)
						for(int k=0; k < qbt.getAggConstraints().size();k++){
							cvc.getConstraints().add( GenerateConstraintsForHavingClause.getHavingClauseConstraints(cvc, qbt, qbt.getAggConstraints().get(k), qbt.getFinalCount(), j));
						}
					cvc.getConstraints().add(ConstraintGenerator.addCommentLine("END OF HAVING CLAUSE CONSTRAINTS FOR SUBQUERY BLOCK "));

					/** get the equivalence classes in which this group by node is present */
					Vector<Vector<Node>> equivalenceClassGroupBy = new Vector<Vector<Node>>();
					Vector<Vector<Node>> equivalence = new Vector<Vector<Node>>();
					for(ConjunctQueryStructure conj: qbt.getConjunctsQs())
						equivalence.addAll(conj.getEquivalenceClasses());
					for(Vector<Node> ec: equivalence)
						if(ec.contains(tempgroupByNode))
							equivalenceClassGroupBy.add(ec);




					/** all group by attributes except this group by node (or the group by nodes which are in the same equivalence class of this node) must be same in the group */
					ArrayList<Node> groupNodes = new ArrayList<Node>();
					for(Node n: groupbyNodes){

						boolean flag = false;
						for(Vector<Node> ec: equivalenceClassGroupBy)/** If this group by node is involved in joins with other group by attribute then they both must contain same value */
							if(ec.contains(n))
								flag = true;
						if(flag)
							continue;

						if(!n.equals(tempgroupByNode))
							groupNodes.add(n);
					}
					
					/** add same group by constraints for this query block */
					cvc.getConstraints().add(ConstraintGenerator.addCommentLine("GROUP BY ATTRIBUTES MUST BE SAME IN SAME GROUP  INSIDE WHERE CLAUSE SUBQUERY BLOCK "));
					/**If there are multiple groups then we should ensure that these are distinct across multiple group*/
					cvc.getConstraints().add( GenerateGroupByConstraints.getGroupByConstraints(cvc, groupNodes, true, qbt.getNoOfGroups()) );

					/** add  constraints to kill this mutation */
					cvc.getConstraints().add( ConstraintGenerator.addCommentLine("CONSTRAINTS TO KILL PARTIAL GROUP BY MUTATIONS WITH SINGLE GROUPS INSIDE WHERE CLAUSE SUBQUERY BLOCK "));
					cvc.getConstraints().add( GenerateConstraintsForPartialGroup_case2.getConstraintsForPartialSingleGroup(cvc, qbt, tempgroupByNode) );
					cvc.getConstraints().add( ConstraintGenerator.addCommentLine("END OF CONSTRAINTS TO KILL PARTIAL GROUP BY MUTATIONS WITH SINGLE GROUPS INSIDE WHERE CLAUSE SUBQUERY BLOCK "));

					/**FIXME: If any nodes in the equivalence classes of this group by attribute are unique and that table contains only a single tuple then it violates foreignkey relationship
					 * This group by node may involve in joins with outer block or other sub query node, let say 'x'
					 * If 'x' is unique and the number of tuples (or groups in case of other sub query) is '1' then it violates foreign key relationship. (Because we are not aincreasing tuples in foreign key if they are involved in joins)
					 * So we should increase the number of tuples in this case 
					 * So we should add the equivalence classes of outer query block and other from clause sub queries*/

					equivalence = new Vector<Vector<Node>>();
					for(QueryBlockDetails qbb: cvc.getOuterBlock().getFromClauseSubQueries())
						if(!qbb.equals(qbt))
							for(ConjunctQueryStructure cn: qbb.getConjunctsQs())
								equivalence.addAll(cn.getEquivalenceClasses());
					for(ConjunctQueryStructure cn: cvc.getOuterBlock().getConjunctsQs())
						equivalence.addAll(cn.getEquivalenceClasses());

//FIXME: UNCOMMENT IT					cvc.getConstraints().add(GenerateConstraintsForPartialGroup_case2.adjustNoOfTuplesForiegnKeyTables(cvc, qbt, tempgroupByNode, equivalence));	

					/** Call the method for the data generation*/
					GenerateCommonConstraintsForQuery.generateDataSetForConstraints(cvc);
					
				}
			}
		}
		
		/** Revert back to the old assignment */
		cvc.setNoOfTuples( (HashMap<String, Integer>) noOfTuplesOrig.clone() );
		
///		cvc.setNoOfOutputTuples( (HashMap<String, Integer>) noOfOutputTuplesOrig.clone() );
		cvc.setRepeatedRelNextTuplePos( (HashMap<String, Integer[]>)repeatedRelNextTuplePosOrig.clone() );
	}

}
