package killMutations.whereClauseNestedBlock;

import generateConstraints.ConstraintGenerator;
import generateConstraints.GenerateCommonConstraintsForQuery;
import generateConstraints.GenerateConstraintsForConjunct;
import generateConstraints.GenerateConstraintsForHavingClause;
import generateConstraints.GenerateConstraintsForPartialMultipleGroup;
import generateConstraints.GenerateConstraintsForWhereClauseSubQueryBlock;
import generateConstraints.GenerateGroupByConstraints;
import generateConstraints.UtilsRelatedToNode;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

import parsing.ConjunctQueryStructure;
import parsing.Node;
import testDataGen.GenerateCVC1;
import testDataGen.QueryBlockDetails;
import util.TagDatasets;


/**
 * This class Generates data to kill partial group by mutations inside where clause sub query block
 * @author mahesh
 *
 */
public class PartialGroupByMutationsInWhereSubQuery_case1 {

	private static Logger logger = Logger.getLogger(PartialGroupByMutationsInWhereSubQuery_case1.class.getName());
	/**
	 * Generates data sets for killing partial group by attributes
	 * The data sets generated by this function are only capable of killing the mutations only if the group by attribute is projected in select list 
	 * @param cvc
	 */
	public static void generateDataForkillingParialGroupByMutationsInWhereSubquery(GenerateCVC1 cvc) throws Exception{

		/** keep a copy of this tuple assignment values */
		//HashMap<String, Integer> noOfOutputTuplesOrig = (HashMap<String, Integer>) cvc.getNoOfOutputTuples().clone();
		HashMap<String, Integer> noOfTuplesOrig = (HashMap<String, Integer>) cvc.getNoOfTuples().clone();
		HashMap<String, Integer[]> repeatedRelNextTuplePosOrig = (HashMap<String, Integer[]>)cvc.getRepeatedRelNextTuplePos().clone();

		/** we have to check if there are where clause sub queries in each conjunct of outer block of query */
		for(ConjunctQueryStructure con: cvc.getOuterBlock().getConjunctsQs()){

			/**For each where clause sub query blocks of this conjunct*/
			/** Kill partial group by  mutations in each where clause nested block of this query*/
			for(Node subQCond: con.getAllSubQueryConds()){

				/** get the index of this sub query node */
				int index = UtilsRelatedToNode.getQueryIndexOfSubQNode(subQCond);

				/** get the where clause sub query block */
				QueryBlockDetails qbt = cvc.getOuterBlock().getWhereClauseSubQueries().get(index);

			    logger.log(Level.INFO,"\n----------------------------------");
				logger.log(Level.INFO,"GENERATE DATA FOR KILLING PARTIAL GROUP BY MUTATIONS IN WHERE CLAUSE NESTED SUBQUERY BLOCK: Case 1: "+ qbt);
				logger.log(Level.INFO,"----------------------------------\n");
							
				/**Get group by nodes of this sub query block*/
				ArrayList<Node> groupbyNodes = (ArrayList<Node>)qbt.getGroupByNodes().clone();

				/**kill each group by attribute at a time*/
				for(Node tempgroupByNode : groupbyNodes){

				    logger.log(Level.INFO,"\n----------------------------------");
					logger.log(Level.INFO,"KILLING PARTIAL GROUP BY MUTATIONS IN WHERE CLAUSE NESTED SUBQUERY BLOCK: " + tempgroupByNode);
					logger.log(Level.INFO,"\n----------------------------------");
								
					/** Initialize the data structures for generating the data to kill this mutation */
					cvc.inititalizeForDatasetQs();


					/**set the type of mutation we are trying to kill*/
					cvc.setTypeOfMutation( TagDatasets.MutationType.PARTIALGROUPBY1, TagDatasets.QueryBlock.WHERE_SUBQUERY );
					
					/** get the tuple assignment for this query
					 * If no possible assignment then not possible to kill this mutation*/
					if(GenerateCVC1.tupleAssignmentForQuery(cvc) == false)
						continue;

					/**We need to generate two groups for this query block,
					 *  we should update the total number of tuples data structure*/
					cvc.updateTotalNoOfOutputTuples( qbt, 2);
					
					
					/** Add constraints for all the From clause nested sub query blocks */
					for(QueryBlockDetails qb: cvc.getOuterBlock().getFromClauseSubQueries()){						
						cvc.getConstraints().add(ConstraintGenerator.addCommentLine(" FROM CLAUSE SUBQUERY "));

						cvc.getConstraints().add( QueryBlockDetails.getConstraintsForQueryBlock(cvc, qb) );

						cvc.getConstraints().add(ConstraintGenerator.addCommentLine(" END OF FROM CLAUSE SUBQUERY "));						
					}

					/**add the negative constraints for all the other conjuncts of outer query block */
					for(ConjunctQueryStructure outer: cvc.getOuterBlock().getConjunctsQs())
						if( !outer.equals(con))
							cvc.getConstraints().add( GenerateConstraintsForConjunct.generateNegativeConstraintsConjunct(cvc, cvc.getOuterBlock(), outer) );

					/** add group by and having clause constraints for outer query block */
					cvc.getConstraints().add( QueryBlockDetails.getGroupByAndHavingClauseConstraints(cvc, cvc.getOuterBlock())) ;

					/**Add other related constraints for the outer query block */
					cvc.getConstraints().add( QueryBlockDetails.getOtherConstraintsForQueryBlock(cvc, cvc.getOuterBlock())) ;


					/** Add all the constraints for this outer block conjunct except where clause sub query block constraints */
					cvc.getConstraints().add( GenerateConstraintsForConjunct.getConstraintsForConjuctExceptWhereClauseSubQueryBlock(cvc, qbt, con) );

					/** get  where clause sub query block constraints for this conjunct. 
					 * Here we should add all the constraints of this conjunct except group by clause constraints of this where clause sub query
					 * But these group by constraints are added in getConstraintsforWhereClauseSubqueryBlock() method 
					 * so we add the constraints of this where clause sub query separately 
					 * get constraints for this sub query block except group by clause constraints
					 * Add the positive conditions for each conjunct of this query block */

					String constraintString = "";

					if(con.getAllSubQueryConds() != null){
						for(int i=0; i < con.getAllSubQueryConds().size(); i++){

							Node subQ = con.getAllSubQueryConds().get(i);
							constraintString +=ConstraintGenerator.addCommentLine("CONSTRAINTS FOR WHERE CLAUSE SUBQUERY CONNECTIVE ");
							constraintString += GenerateConstraintsForWhereClauseSubQueryBlock.getConstraintsForWhereSubQueryConnective(cvc, cvc.getOuterBlock(), subQ);

							constraintString += ConstraintGenerator.addCommentLine("CONSTRAINTS FOR CONDITIONS INSIDE WHERE CLAUSE SUBQUERY CONNECTIVE ");

							constraintString += GenerateConstraintsForWhereClauseSubQueryBlock.getCVCForCondsInSubQ(cvc, cvc.getOuterBlock(), subQ);				

							constraintString += ConstraintGenerator.addCommentLine("END OF CONSTRAINTS FOR CONDITIONS INSIDE WHERE CLAUSE SUBQUERY CONNECTIVE ");
						}
					}

					cvc.getConstraints().add(constraintString);

					/** Generate havingClause constraints for this sub query block*/
					cvc.getConstraints().add(ConstraintGenerator.addCommentLine("HAVING CLAUSE CONSTRAINTS FOR SUBQUERY BLOCK "));
					for(int j=0; j< qbt.getNoOfGroups();j ++)
						for(int k=0; k < qbt.getAggConstraints().size();k++){
							cvc.getConstraints().add( GenerateConstraintsForHavingClause.getHavingClauseConstraints(cvc, qbt, qbt.getAggConstraints().get(k), qbt.getFinalCount(), j));
						}
					cvc.getConstraints().add(ConstraintGenerator.addCommentLine("END OF HAVING CLAUSE CONSTRAINTS FOR SUBQUERY BLOCK "));

					/** add same group by constraints for this query block */
					cvc.getConstraints().add( ConstraintGenerator.addCommentLine("GROUP BY ATTRIBUTES MUST BE SAME IN SAME GROUP "));

					cvc.getConstraints().add( GenerateGroupByConstraints.getGroupByConstraints(cvc, groupbyNodes, false, qbt.getNoOfGroups()) );

					/** add  constraints to kill this mutation */
					cvc.getConstraints().add( ConstraintGenerator.addCommentLine("CONSTRAINTS TO KILL PARTIAL GROUP BY MUTATIONS WITH MULTIPLE GROUPS "));
					cvc.getConstraints().add( GenerateConstraintsForPartialMultipleGroup.getConstraintsForPartialMultipleGroup(cvc, qbt, tempgroupByNode) );
					cvc.getConstraints().add(ConstraintGenerator.addCommentLine("END OF CONSTRAINTS TO KILL PARTIAL GROUP BY MUTATIONS WITH MULTIPLE GROUPS "));

					/** Call the method for the data generation*/
					GenerateCommonConstraintsForQuery.generateDataSetForConstraints(cvc);
				}
			}
		}


		/** Revert back to the old assignment */
		cvc.setNoOfTuples( (HashMap<String, Integer>) noOfTuplesOrig.clone() );
//		cvc.setNoOfOutputTuples( (HashMap<String, Integer>) noOfOutputTuplesOrig.clone() );
		cvc.setRepeatedRelNextTuplePos( (HashMap<String, Integer[]>)repeatedRelNextTuplePosOrig.clone() );
	}

}
