package killMutations.outerQueryBlock;

import generateConstraints.ConstraintGenerator;
import generateConstraints.GenerateCommonConstraintsForQuery;
import generateConstraints.GenerateConstraintsForConjunct;
import generateConstraints.GenerateConstraintsForHavingClause;
import generateConstraints.GenerateConstraintsForPartialGroup_case2;
import generateConstraints.GenerateGroupByConstraints;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Vector;
import java.util.concurrent.TimeoutException;
import java.util.logging.Level;
import java.util.logging.Logger;

import parsing.ConjunctQueryStructure;
import parsing.Node;
import testDataGen.CountEstimationRelated;
import testDataGen.GenerateCVC1;
import testDataGen.QueryBlockDetails;
import util.TagDatasets;

/**
 * This class Generates data to kill partial group by mutations inside outer block of the query
 * The data sets generated by this function are only capable of killing the mutations even if the group by attribute is not projected in select list of the output
 * Assumptions: Atleast two tuples are needed to satisfy the aggregation constraint. Otherwise it is not possible to generate the data sets
 * @author mahesh
 *
 */
public class PartialGroupByMutationsInOuterQueryBlock_case2 {

	private static Logger logger = Logger.getLogger(PartialGroupByMutationsInOuterQueryBlock_case2.class.getName());
	
	public static void generateDataForkillingParialGroupByMutationsInOuterQueryBlockGen(GenerateCVC1 cvc) throws Exception{
		if(cvc.getConstraintSolver().equalsIgnoreCase("cvc3")){
			generateDataForkillingParialGroupByMutationsInOuterQueryBlock(cvc);
		}
		else{
			//generateDataForkillingParialGroupByMutationsInOuterQueryBlockSMT(cvc);
		}
	}
	/**
	 *  Generates data sets for killing partial group by attributes 
	 * @param cvc
	 */
	public static void generateDataForkillingParialGroupByMutationsInOuterQueryBlock(GenerateCVC1 cvc) throws Exception{

		/** keep a copy of this tuple assignment values */
		//HashMap<String, Integer> noOfOutputTuplesOrig = (HashMap<String, Integer>) cvc.getNoOfOutputTuples().clone();
		HashMap<String, Integer> noOfTuplesOrig = (HashMap<String, Integer>) cvc.getNoOfTuples().clone();
		HashMap<String, Integer[]> repeatedRelNextTuplePosOrig = (HashMap<String, Integer[]>)cvc.getRepeatedRelNextTuplePos().clone();

		/**Get outer query block */
		QueryBlockDetails outer = cvc.getOuterBlock();

		logger.log(Level.INFO,"\n----------------------------------");
		logger.log(Level.INFO,"GENERATE DATA FOR KILLING PARTIAL GROUP BY MUTATION IN OUTER BLOCK OF QUERY: Case 2: " + outer);
		logger.log(Level.INFO,"\n----------------------------------\n");
		try{
			/**Get group by nodes of this query block*/
			ArrayList<Node> groupbyNodes = (ArrayList<Node>)outer.getGroupByNodes().clone();
	
			/**kill each group by attribute at a time*/
			for(Node tempgroupByNode : groupbyNodes){
	
				logger.log(Level.INFO,"\n----------------------------------");
				logger.log(Level.INFO,"KILLING PARTIAL GROUP BY MUTATIONS IN OUTER BLOCK OF QUERY: " + tempgroupByNode);
				logger.log(Level.INFO,"\n----------------------------------\n");
				
				/**To indicate if there is constrained aggregation*/
				boolean noAggregation = false;
	
				/** Initialize the data structures for generating the data to kill this mutation */
				cvc.inititalizeForDatasetQs();
	
				/**set the type of mutation we are trying to kill*/
				cvc.setTypeOfMutation( TagDatasets.MutationType.PARTIALGROUPBY2, TagDatasets.QueryBlock.OUTER_BLOCK );
	
				/** get the equivalence classes in which this group by node is present */
				Vector<Vector<Node>> equivalenceClassGroupBy = new Vector<Vector<Node>>();
				
				Vector<Vector<Node>> equivalence = new Vector<Vector<Node>>();
				
				ArrayList<Node> removeList = new ArrayList<Node>();
				removeList.add(tempgroupByNode);
				
				for(ConjunctQueryStructure con: outer.getConjunctsQs())
					equivalence.addAll(con.getEquivalenceClasses());
				
				for(Vector<Node> ec: equivalence)
					if(ec.contains(tempgroupByNode))
						equivalenceClassGroupBy.add(ec);
	
				/** all group by attributes except this group by node (or the group by nodes which are in the same equivalence class of this node) must be same in the group */
				ArrayList<Node> groupNodes = new ArrayList<Node>();
				for(Node n: groupbyNodes){
	
					boolean flag = false;
					for(Vector<Node> ec: equivalenceClassGroupBy)/** If this group by node is involved in joins with other group by attribute then they both must contain same value */
						if(ec.contains(n))
							flag = true;
					if(flag){
						if(!removeList.contains(n)) removeList.add(n);
						continue;
					}
	
					if(!n.equals(tempgroupByNode))
						groupNodes.add(n);
				}
	
				/**If no aggregations then make the count as 2 for this block of query, useful to kill partial group by mutation*/			
				if( outer.getAggConstraints() == null || outer.getAggConstraints().size() == 0 ){
	
					outer.setFinalCount(2);
	
					/**this group by node won't be a single valued any more*/
					outer.getGroupByNodes().removeAll(removeList);
	
					HashSet<Node> unique = new HashSet<Node>();
	
					for(Node n: removeList)
						unique.add(new Node(n));
					
					/**In this group these will have distinct values*/
					outer.getUniqueElementsAdd().add( unique);
	
					/**get tuple assignment*/
					/**assign the number of tuples for the this outer query block*/
					if( QueryBlockDetails.getTupleAssignment( cvc, outer, tempgroupByNode.getTableNameNo()) == false){
						outer.getGroupByNodes().addAll(removeList);
						continue ;
					}
	
					/** flag to indicate whether tuple assignment is possible or not*/
					boolean possible = true;
	
					/** get tuple assignment for each from clause sub query block except this subquery block*/
					for(QueryBlockDetails qb: outer.getFromClauseSubQueries() ){
	
						possible = CountEstimationRelated.estimateCountAndgetTupleAssignmentForQueryBlock(cvc, qb);
	
						/** If tuple assignment is not possible*/
						if(possible == false)
							break;
					}
					if(possible == false){
						outer.getGroupByNodes().addAll(removeList);
						continue ;
					}
	
					/** get tuple assignment for each where clause sub query block*/
					for(QueryBlockDetails qb: outer.getWhereClauseSubQueries()){
	
						possible = CountEstimationRelated.estimateCountAndgetTupleAssignmentForQueryBlock(cvc, qb);
	
						/** If tuple assignment is not possible*/
						if(possible == false)
							break;
					}
	
					if(possible == false){
						outer.getGroupByNodes().addAll(removeList);
						continue ;
					}	
	
					noAggregation = true;
				}
	
				/**FIXME: Does this group by attribute affect tuple assignment*/
				/** get the tuple assignment for this query, if there are constrained aggregation
				 * If no possible assignment then not possible to kill this mutation*/
				else
					if(GenerateCVC1.tupleAssignmentForQuery(cvc) == false)
						continue;		
	
	
	
				/** Add constraints for all the From clause nested sub query blocks */
				for(QueryBlockDetails qb: cvc.getOuterBlock().getFromClauseSubQueries()){						
					cvc.getConstraints().add(ConstraintGenerator.addCommentLine(" FROM CLAUSE SUBQUERY "));
	
					cvc.getConstraints().add( QueryBlockDetails.getConstraintsForQueryBlock(cvc, qb) );
	
					cvc.getConstraints().add(ConstraintGenerator.addCommentLine("END OF FROM CLAUSE SUBQUERY "));						
				}
	
				/** get constraints for this sub query block except group by clause constraints*/
				/** Add the positive conditions for each conjunct of this query block */
				for(ConjunctQueryStructure conjunct : outer.getConjunctsQs()){
					cvc.getConstraints().add(ConstraintGenerator.addCommentLine("CONSTRAINTS FOR THIS CONJUNCT "));
					cvc.getConstraints().add( GenerateConstraintsForConjunct.getConstraintsForConjuct(cvc, outer, conjunct) );
					cvc.getConstraints().add(ConstraintGenerator.addCommentLine("END OF CONSTRAINTS FOR THIS CONJUNCT "));				
				}
	
				/**Add other related constraints for outer query block */
				cvc.getConstraints().add( QueryBlockDetails.getOtherConstraintsForQueryBlock(cvc, outer) );
	
				/**FIXME: Make this aggregation constraint to fail in distinct tuples of killing group by attribute*/
	
				/** Generate havingClause constraints for this sub query block*/
				cvc.getConstraints().add(ConstraintGenerator.addCommentLine("HAVING CLAUSE CONSTRAINTS FOR SUBQUERY BLOCK"));
				for(int j=0; j< outer.getNoOfGroups();j ++)
					for(int k=0; k < outer.getAggConstraints().size();k++){
						cvc.getConstraints().add( GenerateConstraintsForHavingClause.getHavingClauseConstraints(cvc, outer, outer.getAggConstraints().get(k), outer.getFinalCount(), j));
					}
				
				cvc.getConstraints().add(ConstraintGenerator.addCommentLine("END OF HAVING CLAUSE CONSTRAINTS FOR SUBQUERY BLOCK"));
	
				/** add same group by constraints for this query block */
				cvc.getConstraints().add(ConstraintGenerator.addCommentLine("GROUP BY ATTRIBUTES MUST BE SAME IN SAME GROUP INSIDE OUTER BLOCK OF QUERY"));
				/**If there are multiple groups then we should ensure that these are distinct across multiple group*/
				cvc.getConstraints().add( GenerateGroupByConstraints.getGroupByConstraints(cvc, groupNodes, true, outer.getNoOfGroups()) );
	
				/** add  constraints to kill this mutation */
				cvc.getConstraints().add( ConstraintGenerator.addCommentLine("CONSTRAINTS TO KILL PARTIAL GROUP BY MUTATIONS WITH SINGLE GROUPS INSIDE OUTER BLOCK OF QUERY"));
				cvc.getConstraints().add( GenerateConstraintsForPartialGroup_case2.getConstraintsForPartialSingleGroup(cvc, outer, tempgroupByNode) );
				cvc.getConstraints().add( ConstraintGenerator.addCommentLine("END OF CONSTRAINTS TO KILL PARTIAL GROUP BY MUTATIONS WITH SINGLE GROUPS INSIDE OUTER BLOCK OF QUERY"));
	
				/**FIXME: If any nodes in the equivalence classes of this group by attribute are unique and that table contains only a single tuple then it violates foreignkey relationship
				 * This group by node may involve in joins with outer block or other sub query node, let say 'x'
				 * If 'x' is unique and the number of tuples (or groups in case of other sub query) is '1' then it violates foreign key relationship. (Because we are not aincreasing tuples in foreign key if they are involved in joins)
				 * So we should increase the number of tuples in this case 
				 * So we should add the equivalence classes of outer query block and other from clause sub queries*/
	
				equivalence = new Vector<Vector<Node>>();
				for(QueryBlockDetails qbb: cvc.getOuterBlock().getFromClauseSubQueries())
					if(!qbb.equals(outer))
						for(ConjunctQueryStructure cn: qbb.getConjunctsQs())
							equivalence.addAll(cn.getEquivalenceClasses());
				for(ConjunctQueryStructure cn: cvc.getOuterBlock().getConjunctsQs())
					equivalence.addAll(cn.getEquivalenceClasses());
	
				//FIXME: UNCOMMENT IT			cvc.getConstraints().add(GenerateConstraintsForPartialGroup_case2.adjustNoOfTuplesForiegnKeyTables(cvc, outer, tempgroupByNode, equivalence));	
	
				/** Call the method for the data generation*/
				GenerateCommonConstraintsForQuery.generateDataSetForConstraints(cvc);
	
				if(noAggregation)
					outer.getGroupByNodes().addAll(removeList);
			}
	
	
			/** Revert back to the old assignment */
			cvc.setNoOfTuples( (HashMap<String, Integer>) noOfTuplesOrig.clone() );
			//		cvc.setNoOfOutputTuples( (HashMap<String, Integer>) noOfOutputTuplesOrig.clone() );
			cvc.setRepeatedRelNextTuplePos( (HashMap<String, Integer[]>)repeatedRelNextTuplePosOrig.clone() );
		}catch (TimeoutException e){
			logger.log(Level.SEVERE,e.getMessage(),e);		
			throw e;
		}catch(Exception e){
			logger.log(Level.SEVERE,e.getMessage(),e);
			throw e;
		}
	}

}
