package killMutations.fromClauseNestedBlock;

import generateConstraints.ConstraintGenerator;
import generateConstraints.GenerateCommonConstraintsForQuery;
import generateConstraints.GenerateConstraintsForConjunct;
import generateConstraints.GenerateConstraintsForHavingClause;
import generateConstraints.GenerateConstraintsForPartialMultipleGroup;
import generateConstraints.GenerateGroupByConstraints;

import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

import parsing.ConjunctQueryStructure;
import parsing.Node;
import testDataGen.CountEstimationRelated;
import testDataGen.GenerateCVC1;
import testDataGen.QueryBlockDetails;
import util.TagDatasets;

/**
 * This class Generates data to kill partial group by mutations inside from clause sub query block
 * @author mahesh
 *
 */
public class PartialGroupByMutationsInFromSubQuery_case1 {

	private static Logger logger = Logger.getLogger(PartialGroupByMutationsInFromSubQuery_case1.class.getName()); 
	/**
	 * Generates data sets for killing partial group by attributes
	 * The data sets generated by this function are only capable of killing the mutations only if the group by attribute is projected in select list 
	 * @param cvc
	 */
	public static void generateDataForkillingParialGroupByMutationsInFromSubquery(GenerateCVC1 cvc) throws Exception{

		/** keep a copy of this tuple assignment values */
		//HashMap<String, Integer> noOfOutputTuplesOrig = (HashMap<String, Integer>) cvc.getNoOfOutputTuples().clone();
		HashMap<String, Integer> noOfTuplesOrig = (HashMap<String, Integer>) cvc.getNoOfTuples().clone();
		HashMap<String, Integer[]> repeatedRelNextTuplePosOrig = (HashMap<String, Integer[]>)cvc.getRepeatedRelNextTuplePos().clone();
		
		/** Kill partial group by mutations in each from clause nested block of this query*/
		for(QueryBlockDetails qbt: cvc.getOuterBlock().getFromClauseSubQueries()){
			
			logger.log(Level.INFO,"\n----------------------------------");
			logger.log(Level.INFO,"GENERATE DATA FOR KILLING PARTIAL GROUP BY MUTATIONS IN FROM CLAUSE NESTED SUBQUERY BLOCK: Case 1");
			logger.log(Level.INFO,"----------------------------------\n");
			
			/**Get group by nodes of this subquery block*/
			ArrayList<Node> groupbyNodes = (ArrayList<Node>)qbt.getGroupByNodes().clone();
			
			/**kill each group by attribute at a time*/
			for(Node tempgroupByNode : groupbyNodes){
				
				logger.log(Level.INFO,"\n----------------------------------");
				logger.log(Level.INFO,"KILLING PARTIAL GROUP BY MUTATIONS IN FROM CLAUSE NESTED SUBQUERY BLOCK: " + tempgroupByNode);
				logger.log(Level.INFO,"\n----------------------------------");
				
				/** Initialize the data structures for generating the data to kill this mutation */
				cvc.inititalizeForDatasetQs();

				/**set the type of mutation we are trying to kill*/
				cvc.setTypeOfMutation( TagDatasets.MutationType.PARTIALGROUPBY1, TagDatasets.QueryBlock.FROM_SUBQUERY );
				
				/** Add this group node to the list of unique elements of the outer block of this query block*/
				HashSet<Node> unique = new HashSet<Node>();
				unique.add(new Node(tempgroupByNode));
				
				/**FIXME: Not only this node but all the nodes which have join condition with this*/
				/** This group by node becomes unique in two groups. Hence it is added to the list of unique elements of outer query block of this query block*/
				cvc.getOuterBlock().getUniqueElementsAdd().add(unique);
				
				
				/** The remaining group by attributes will have same value across two groups. Hence they are added to the single valued list, 
				 * iff they are projected in the sub query */
				for(Node gn: groupbyNodes)
					if(!tempgroupByNode.equals(gn) && cvc.getOuterBlock().getProjectedCols().contains(gn))
						cvc.getOuterBlock().getSingleValuedAttributesAdd().add(new Node(gn));
				
				/**Here this from clause sub query block generates two groups of data 
				 * We should force the outer query tuple assignment method to choose this from clause nested sub query node as root node */
				/**FIXME: But the outer query block may need more than two tuples to satisfy constrained aggregation*/
				
				/** Get the number of tuples needed to satisfy this constrained aggregation,if any, for the outer query block*/
				if(cvc.getOuterBlock().getAggConstraints() != null && cvc.getOuterBlock().getAggConstraints().size() != 0 )
					cvc.getOuterBlock().setFinalCount( CountEstimationRelated.estimateNoOfTuples( cvc, cvc.getOuterBlock(), 0) );
				else/**If there is no constrained in outer query block*/
					cvc.getOuterBlock().setFinalCount( 2 );/**Two groups are generated by the from clause nested sub query block*/
				
				/**FIXME: What if constrained aggregation needs only one tuple*/
				if(cvc.getOuterBlock().getFinalCount() < 2)
					cvc.getOuterBlock().setFinalCount( 2 );
				
				/**Get the tuple assignment of the outer query block*/
				/**Here we should select this from clause sub query block as the root node for the tuple assignment*/
				if( QueryBlockDetails.getTupleAssignment( cvc, cvc.getOuterBlock(), tempgroupByNode.getTableNameNo()) == false)
					continue ;
				
				/**Get the tuple assignment for the sub query blocks*/
				if( GenerateCVC1.getTupleAssignmentForSubQueries(cvc) == false)
					continue;
				
				/**Remove this sub query group by node. Needed to avoid conflicts between multiple group and unique key constraints*/
				/**FIXME: But not working*/
				cvc.getOuterBlock().getUniqueElements().remove(tempgroupByNode);
				
				/** Get constraints for outer query block*/
				/**This also adds constraints for the where clause nested sub query block */
				cvc.getConstraints().add( QueryBlockDetails.getConstraintsForQueryBlockExceptSubQuries(cvc, cvc.getOuterBlock()) );
				
				/** Add constraints for all the From clause nested sub query blocks except this sub query block */
				for(QueryBlockDetails qb: cvc.getOuterBlock().getFromClauseSubQueries()){
					if(!(qb.equals(qbt))){
						cvc.getConstraints().add(ConstraintGenerator.addCommentLine(" FROM CLAUSE SUBQUERY "));
						
						cvc.getConstraints().add( QueryBlockDetails.getConstraintsForQueryBlock(cvc, qb) );
						
						cvc.getConstraints().add(ConstraintGenerator.addCommentLine(" END OF FROM CLAUSE SUBQUERY "));
					}
				}
				
				/** get constraints for this sub query block except group by clause constraints*/
				/** Add the positive conditions for each conjunct of this query block */
				for(ConjunctQueryStructure conjunct : qbt.getConjunctsQs()){
					cvc.getConstraints().add(ConstraintGenerator.addCommentLine(" CONSTRAINTS FOR THIS CONJUNCT "));
					cvc.getConstraints().add( GenerateConstraintsForConjunct.getConstraintsForConjuct(cvc, qbt, conjunct) );
					cvc.getConstraints().add(ConstraintGenerator.addCommentLine(" END OF CONSTRAINTS FOR THIS CONJUNCT "));		
				}
				
				/**Add other related constraints for this query block */
				cvc.getConstraints().add( QueryBlockDetails.getOtherConstraintsForQueryBlock(cvc, qbt) );
				
				/** Generate havingClause constraints for this sub query block*/
				cvc.getConstraints().add(ConstraintGenerator.addCommentLine("HAVING CLAUSE CONSTRAINTS FOR SUBQUERY BLOCK "));
				for(int j=0; j< qbt.getNoOfGroups();j ++)
					for(int k=0; k < qbt.getAggConstraints().size();k++){
						cvc.getConstraints().add( GenerateConstraintsForHavingClause.getHavingClauseConstraints(cvc, qbt, qbt.getAggConstraints().get(k), qbt.getFinalCount(), j));
					}
				cvc.getConstraints().add(ConstraintGenerator.addCommentLine("END OF HAVING CLAUSE CONSTRAINTS FOR SUBQUERY BLOCK "));
				
				/** add same group by constraints for this query block */
				cvc.getConstraints().add( ConstraintGenerator.addCommentLine("GROUP BY ATTRIBUTES MUST BE SAME IN SAME GROUP "));				
				cvc.getConstraints().add( GenerateGroupByConstraints.getGroupByConstraints(cvc,  groupbyNodes, false, qbt.getNoOfGroups()) );
				
				/** add  constraints to kill this mutation */
				cvc.getConstraints().add( ConstraintGenerator.addCommentLine("CONSTRAINTS TO KILL PARTIAL GROUP BY MUTATIONS WITH MULTIPLE GROUPS "));
				cvc.getConstraints().add( GenerateConstraintsForPartialMultipleGroup.getConstraintsForPartialMultipleGroup(cvc, qbt, tempgroupByNode) );
				cvc.getConstraints().add( ConstraintGenerator.addCommentLine("END OF CONSTRAINTS TO KILL PARTIAL GROUP BY MUTATIONS WITH MULTIPLE GROUPS "));
				
				/** Call the method for the data generation*/
				GenerateCommonConstraintsForQuery.generateDataSetForConstraints(cvc);
			}
		}
		
		/** Revert back to the old assignment */
		cvc.setNoOfTuples( (HashMap<String, Integer>) noOfTuplesOrig.clone() );
//		cvc.setNoOfOutputTuples( (HashMap<String, Integer>) noOfOutputTuplesOrig.clone() );
		cvc.setRepeatedRelNextTuplePos( (HashMap<String, Integer[]>)repeatedRelNextTuplePosOrig.clone() );

	}

}
